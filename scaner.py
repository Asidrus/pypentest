import asyncio


def run(tasks, *, loop=None):
    if loop is None:
        loop = asyncio.get_event_loop()
    # waiting for all tasks
    return loop.run_until_complete(asyncio.wait(tasks))


# {"IP": "", "PORT": XXXX, "STATUS": "Opened, "INFO": ""}
iptable = []


async def scanner(ip, port, loop=None):
    fut = asyncio.open_connection(ip, port, loop=loop)
    try:
        reader, writer = await asyncio.wait_for(fut, timeout=1)
        banner = ""
        try:
            while True:
                chunk = await asyncio.wait_for(reader.read(2 * 4), timeout=1)
                banner += chunk.decode("utf-8")
        except asyncio.TimeoutError:
            pass
        iptable.append({"IP": ip, "PORT": port, "STATUS": "Opened", "INFO": banner.replace("\r\n", " | ")})
    except asyncio.TimeoutError:
        iptable.append({"IP": ip, "PORT": port, "STATUS": "Closed"})
        pass
    # handle connection refused and bunch of others
    except Exception as exc:
        # print('Error {}:{} {}'.format(ip, port, exc))
        iptable.append({"IP": ip, "PORT": port, "STATUS": "Error", "INFO": str(exc)})


def scan(ips, ports):
    loop = asyncio.get_event_loop()
    run([scanner(ip, port) for port in ports for ip in ips])


if __name__ == "__main__":
    ports = [i for i in range(0, 1024)]
    scan(["80.87.200.64"], ports)
    # scan(["80.87.192.66"], ports)
    # scan(["192.168.1.1"], ports)
    for addr in iptable:
        if addr["STATUS"] == "Opened":
            print(addr)

